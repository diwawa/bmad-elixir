# Phoenix 最佳实践检查清单

在实现 Phoenix 功能时使用此检查清单，以确保遵循既定模式和最佳实践。

## 上下文设计

### 有界上下文
- [ ] 上下文有明确的单一职责
- [ ] 上下文名称代表一个领域概念（Accounts、Billing、Content，而不是 "Helpers"）
- [ ] 公共 API 最小且定义明确
- [ ] 内部/私有函数明确标记
- [ ] 上下文之间无循环依赖

### 函数
- [ ] 公共函数记录其返回类型
- [ ] 函数返回 `{:ok, result}` 或 `{:error, reason}` 元组
- [ ] 感叹号函数（!）为预期错误引发异常
- [ ] 查询函数没有副作用
- [ ] 变异清楚地表明它们修改数据

## 控制器

### 结构
- [ ] 控制器是瘦的 - 业务逻辑在上下文中
- [ ] 每个资源的每个 HTTP 动词一个操作
- [ ] 通过操作回退控制器进行错误处理
- [ ] 返回适当的 HTTP 状态码（200、201、204、400、404 等）

### JSON API
- [ ] 请求验证在变更集中，不在控制器中
- [ ] 一致的 JSON 响应格式
- [ ] 响应中适当的错误消息
- [ ] 如果是公共 API 则进行 API 版本控制

### Web 控制器
- [ ] 用于用户反馈的 Flash 消息
- [ ] POST/PUT/DELETE 后重定向
- [ ] 表单错误清晰显示
- [ ] CSRF 保护已启用

## 路由器

### 路由
- [ ] RESTful 路由遵循约定
- [ ] 嵌套路由限制为 1-2 级
- [ ] 模板中使用命名路由（`~p"/users/#{user}"`）
- [ ] 路由按关注点/上下文组织
- [ ] API 路由使用 `/api` 前缀

### 管道
- [ ] 路由中的认证要求，而不是单个操作
- [ ] 管道由小的、专注的插件组成
- [ ] 浏览器管道包括 CSRF、获取会话/Flash
- [ ] API 管道最小（无 CSRF、会话）

## 模板与组件

### HEEx 模板
- [ ] 使用核心组件中的函数组件（`<.component>`）
- [ ] 最小化模板中的逻辑
- [ ] 提取可重用标记到组件
- [ ] 无内联样式（使用 Tailwind 类）
- [ ] 无障碍属性（aria-*、alt、label）

### 组件
- [ ] 组件是纯函数
- [ ] 插槽用于灵活布局
- [ ] 用 attr/3 验证属性
- [ ] 在上下文中可重用
- [ ] 用示例良好文档化

## 安全

### 认证与授权
- [ ] 认证在插件管道中
- [ ] 每个操作中的授权检查
- [ ] 无法访问其他用户的数据
- [ ] 适当的会话管理
- [ ] 安全密码哈希（bcrypt）

### 输入验证
- [ ] 所有用户输入都经过验证
- [ ] 变更集验证全面
- [ ] 防止 SQL 注入（使用 Ecto 查询）
- [ ] 防止 XSS（HEEx 自动转义）
- [ ] CSRF 保护已启用

### 密钥
- [ ] 源代码中无密钥
- [ ] 配置使用环境变量
- [ ] 密钥基础正确设置
- [ ] API 密钥未提交

## 性能

### 数据库查询
- [ ] 无 N+1 查询（使用预加载或连接）
- [ ] 外键上有索引
- [ ] 经常查询的字段上有索引
- [ ] 大结果集使用分页
- [ ] 使用 `select` 限制加载的字段

### 缓存
- [ ] 昂贵计算已缓存
- [ ] 缓存失效策略明确
- [ ] API 的 ETag/条件请求
- [ ] 静态资产已加指纹

## 错误处理

### 面向用户的错误
- [ ] 友好的错误消息
- [ ] 404 页面自定义
- [ ] 500 页面自定义
- [ ] 错误跟踪已配置（Sentry、AppSignal 等）

### 开发者错误
- [ ] 日志中有用的错误消息
- [ ] 开发中的堆栈跟踪
- [ ] 错误消息中无敏感数据
- [ ] 错误率已监控

## 测试

### 覆盖率
- [ ] 所有公共上下文函数已测试
- [ ] 所有控制器操作已测试
- [ ] 正常路径已覆盖
- [ ] 错误情况已覆盖
- [ ] 边缘情况已识别和测试

### 测试质量
- [ ] 测试可读且可维护
- [ ] 用于测试数据的工厂/夹具函数
- [ ] 测试隔离（无共享状态）
- [ ] 快速测试套件（完整运行 < 30 秒）
- [ ] 可能时异步测试

## 文档

### 代码文档
- [ ] 所有公共模块上的 @moduledoc
- [ ] 所有公共函数上的 @doc
- [ ] @doc 块中的示例
- [ ] 用注释解释复杂逻辑
- [ ] README 最新

### API 文档
- [ ] API 端点文档化（Swagger/OpenAPI）
- [ ] 提供请求/响应示例
- [ ] 错误响应文档化
- [ ] 速率限制文档化

## 配置

### 环境
- [ ] 用于本地工作的开发配置
- [ ] 隔离的测试配置
- [ ] 安全的生产配置
- [ ] 发布中的运行时配置

### 依赖项
- [ ] 最小依赖项
- [ ] 依赖项最新
- [ ] 检查安全漏洞（`mix deps.audit`）
- [ ] 移除未使用的依赖项

## 部署

### 发布
- [ ] 配置 Mix 发布
- [ ] 迁移自动运行或文档化
- [ ] 健康检查端点（`/health`）
- [ ] 优雅关闭处理

### 监控
- [ ] 收集应用程序指标
- [ ] 监控错误率
- [ ] 跟踪性能指标
- [ ] 聚合和可搜索日志

## Phoenix 特定模式

### 上下文
✅ **好：**
```elixir
# 公共 API
def get_user!(id), do: Repo.get!(User, id)
def list_users, do: Repo.all(User)
def create_user(attrs), do: %User{} |> User.changeset(attrs) |> Repo.insert()

# 所有 Repo 调用在上下文内部
```

❌ **坏：**
```elixir
# 控制器直接调用 Repo
def index(conn, _params) do
  users = Repo.all(User)  # 应该在上下文中！
  render(conn, "index.html", users: users)
end
```

### 控制器
✅ **好：**
```elixir
def create(conn, %{"user" => user_params}) do
  case Accounts.create_user(user_params) do
    {:ok, user} ->
      conn
      |> put_flash(:info, "User created successfully")
      |> redirect(to: ~p"/users/#{user}")

    {:error, %Ecto.Changeset{} = changeset} ->
      render(conn, "new.html", changeset: changeset)
  end
end
```

❌ **坏：**
```elixir
def create(conn, %{"user" => user_params}) do
  user = Accounts.create_user!(user_params)  # 未处理异常！
  redirect(conn, to: ~p"/users/#{user}")
end
```

## 要避免的常见陷阱

- ❌ 在控制器中放置业务逻辑
- ❌ 从控制器直接访问 Repo
- ❌ 创建上帝上下文（拆分为更小的上下文）
- ❌ 不测试边缘情况
- ❌ 忽略 N+1 查询警告
- ❌ 不使用数据库约束
- ❌ 以纯文本存储敏感数据
- ❌ 不实现授权检查
- ❌ 使用 `belongs_to` 而不使用 `foreign_key_constraint`
- ❌ 不对大结果集进行分页

## 标记故事完成前

- [ ] 上述所有检查清单项目已审查
- [ ] `mix test` - 所有测试通过
- [ ] `mix credo --strict` - 无问题
- [ ] `mix dialyzer` - 无警告
- [ ] `mix format` - 代码格式化
- [ ] 无编译器警告
- [ ] 文档完整
- [ ] 安全审查完成
- [ ] 性能可接受